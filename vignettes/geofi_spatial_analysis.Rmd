---
title: "Spatial data manipulation and analysis R and geofi-package"
author: "Markus Kainu, Leo Lahti & Joona LehtomÃ¤ki"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Spatial data manipulation and analysis R and geofi-package}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE, 
  warning = FALSE,
  fig.height = 10, 
  fig.width = 7,
  eval = FALSE
)
```

Majority of the operations presented in this vignette derive from [Marko Kallio's](http://markokallio.fi/) course at [CSC](https://www.csc.fi/en/home) in February 2020 [Spatial data analysis with R](https://www.csc.fi/web/training/-/r_spatial_2019).  


**Installation**

`geofi` is not yet in CRAN, but can be installed from Github using

```{r, eval = FALSE}
remotes::install_github("ropengov/geofi")
```


## Coordinate reference systems

Unlike many graphical GIS programs (e.g. ArcGIS, QGIS), R cannot transform objects on the fly. Therefore, having all data in the same CRS is important. Luckily, functions in 'sf' package will give an error if the CRS of input objects is not identical. Inspecting the CRS of an object can be done with *st_crs()* function. Here we load "rivers.gpkg", which is a subset of HydroSheds river network, derived from 15 arc second DEM.

```{r}
basins <- read_sf("Data/basins.gpkg", quiet = TRUE)
rivers <- read_sf("Data/rivers.gpkg", quiet = TRUE)
st_crs(basins)
st_crs(rivers)

# 1st set csr
st_set_crs(rivers, value = st_crs(villages))
# 2nd st_transform
st_transform(rivers, crs = st_crs(villages)) 

```


If we know the CRS of our data, but it is missing from the object, we can set it using *st_set_crs()* function. Note that **this will not transform the coordinates!** Setting can be easily done either by using the EPSG code or proj.4 string. 

```{r message=FALSE, warning=FALSE}
# using EPSG SRID
basins <- st_set_crs(basins, 4326)

# using proj.4 string
basins <- st_set_crs(basins, "+init=epsg:4326")
# basins <- st_set_crs(basins, "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")

# OR
st_crs(basins) <- 4326
# st_crs(basins) <- "+init=epsg:4326"
# st_crs(basins) <- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
```


Coordinate transformations are likewise easy to achieve using *st_transform()* function. The input can be either the EPSG or proj.4 string, as with *st_set_crs()*. Here we transform basins to the same CRS as rivers (UTM zone 48N; EPSG:32648).

```{r}
basins <- st_transform(basins, 32648) 

st_crs(basins)
```


## Simplification, centroids, buffers, clipping, intersection...

Geometric operations include all operations which alter geometries, or result in new ones. Such commands include for instance simplifications, clipping, difference, intersection, computing centroids, buffers etc. 'sf' uses the OGC specifications for these operations, and therefore differ slightly from the terminology used in e.g. ArcGIS or QGIS.


### Union (Dissolve)


Here we create major basins from smaller ones by creating a union of the small geometries based on their attribute "MAIN_BAS". This is equivalent to dissolving in ArcGIS and QGIS. There is no ready made function in 'sf' for this, but we can use the verbs provided in 'dplyr' package. Function st_union() from 'sf' creates a union of all objects in the input geometry (equals dissolving without attributes in ArcGIS or QGIS).

```{r message=FALSE, warning=FALSE}
# The provided st_union() function creates a union of all geometries in the input
( major_basins <- st_union(basins) )

# dissolve to major basins again:
major_basins <- basins %>% 
    group_by(MAIN_BAS) %>% 
    summarize()
plot(major_basins)

```

### Simplify

With the dissolved major basins, we can try simplification using st_simplify(). It operates on each individual geometry separately, and thus does not preserve uniform polygon borders. For polygon feature sets which share borders, we could use function ms_simplify() from 'rmapshaper' package.

```{r message=FALSE, warning=FALSE}
# st_simplify() takes toleranse in the units of CRS. In our case it is UTM, so the unit is meters.
simplified_st <- st_simplify(major_basins, dTolerance = 5000)
plot(simplified_st)

# st_simplify() 
library(rmapshaper, quietly = TRUE)
# keep 1% of nodes. keep_shapes prevents small polygons from disappearing at high simplification
simplified_ms <- ms_simplify(major_basins, keep = 0.01, keep_shapes=TRUE)
plot(simplified_ms)
```



### Centroids

```{r message=FALSE, warning=FALSE}
centroids_sf <- st_centroid(basins)
plot(dplyr::select(basins, UP_AREA), reset = FALSE) # Here using the dplyr::, because also raster package has a function named select(), and it creates conflict. the dplyr:: specifies that it is looking for the function in package 'dplyr'.
plot(centroids_sf, col='white', pch=16, add=TRUE)
```


#### Buffers

Buffers can be taken from any 'sf' object. Here we take a fixed buffer of 5km from the centroid of each feature in major_basins.
```{r message=FALSE, warning=FALSE}
buffer_sf <- major_basins %>%
    st_centroid() %>% 
    st_buffer(dist = 15000)

plot(buffer_sf)
```


Variable buffer are also possible by giving the input argument dist a vector of the same length as there are features in the 'sf' object. Here we take a random buffer 2-10km wide.

```{r message=FALSE, warning=FALSE}
# random buffer distances
buf_dist <- nrow(major_basins) %>% 
    runif(10000, 30000)

# sf
varbuf_sf <- major_basins %>%
    st_centroid() %>% 
    st_buffer(dist = buf_dist)


plot(varbuf_sf, reset = FALSE)
major_basins %>%
    st_cast("LINESTRING") %>%
    plot(col='black', add=TRUE)
```


### Creating regular grids (fishnets)

Fishnets or regular grids of points can be created with *st_make_grid()* function. It creates a regular grid over bounding box of an 'sf' object. Can be given a certain cellsize, or number of cells in x and y directions. 'what' tells the function what kind of regular grid is wanted (polygons, corners, centers). Fishnets of lines rather than polygons can be created simply by casting the polygons as "LINESTRING"s.
The resulting polygon grid is an 'sfc' object, so it needs to be made 'sf' in order for us to add the ID-attribute.

```{r message=FALSE, warning=FALSE}
grid_sf <- st_make_grid(basins, n=c(10,10), what="polygons") %>%
    st_sf()

grid_sf$ID <- 1:NROW(grid_sf)

plot(grid_sf)

```

```{r, eval = FALSE}
library(geofi)
muni <- get_municipalities()
fin <- muni %>% summarise()

grid_sf <- st_make_grid(fin, n=c(50,50), what="polygons") %>%
    st_sf()
plot(grid_sf)

grid_clip <- st_intersection(grid_sf, fin)
# plot(grid_clip, max.plot=2)
grid_clip$rank <- 1:nrow(grid_clip)

ggplot(grid_clip) +
  geom_sf(aes(fill = rank), color = alpha("white", 1/3), size = 3) +
  scale_fill_viridis_c() +
  theme_minimal()
  
```



### Intersection

Say we were interested in villages in a specific river basin. We can take an intersection of villages within that basin. First, let's load the villages from the file, and then inspect it together with the basins.

```{r message=FALSE, warning=FALSE}
villages <- read_sf("Data/villages.gpkg") %>%
    st_transform(32648)

map <- mapview(villages) + basins
map

#select a basin and get all villages intersecting
( vil_sel <- filter(basins, HYBAS_ID == 4061080120) %>%
    st_intersection(villages) )

# If we only want HYBAS_ID from the basins data frame:
( vil_sel <- basins %>% 
    dplyr::select(HYBAS_ID) %>% 
    filter(HYBAS_ID == 4061080120) %>%
    st_intersection(villages) )

# we can use pipes inside functions as well
plot(filter(basins, HYBAS_ID == 4061080120) %>% dplyr::select(HYBAS_ID), 
     reset=FALSE)
plot(st_geometry(vil_sel), pch=16, cex=1, col='white', add=TRUE)

```



### Clipping

Clipping can be done with st_intersection as well. However, for proper clipping we need to have a single polygon feature geometry. For instance, if we wish to cut the polygon grid to the basins dataset, we need to take union of basins and use it to intersect the grid.

```{r message=FALSE, warning=FALSE}
# Does not clip proper
grid_clip <- st_intersection(grid_sf, basins)
plot(grid_clip, max.plot=2)

# Clips proper
grid_clip <- st_intersection(grid_sf, st_union(basins))
plot(grid_clip, max.plot=2)
```

